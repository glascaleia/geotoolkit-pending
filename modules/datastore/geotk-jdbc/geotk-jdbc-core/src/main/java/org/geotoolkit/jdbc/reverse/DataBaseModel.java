/*
 *    Geotoolkit - An Open Source Java GIS Toolkit
 *    http://www.geotoolkit.org
 *
 *    (C) 2011, Geomatys
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation;
 *    version 2.1 of the License.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 */

package org.geotoolkit.jdbc.reverse;

import com.vividsolutions.jts.geom.Geometry;

import java.util.ArrayList;
import java.util.List;
import java.util.HashSet;
import java.util.Collections;
import java.util.logging.Level;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;

import org.geotoolkit.feature.AttributeTypeBuilder;
import org.geotoolkit.feature.AttributeDescriptorBuilder;
import org.geotoolkit.feature.DefaultName;
import org.geotoolkit.feature.FeatureTypeBuilder;
import org.geotoolkit.storage.DataStoreException;
import org.geotoolkit.factory.HintsPending;
import org.geotoolkit.jdbc.DefaultJDBCDataStore;
import org.geotoolkit.jdbc.JDBCDataStore;
import org.geotoolkit.jdbc.dialect.SQLDialect;
import org.geotoolkit.jdbc.fid.PrimaryKeyColumn;
import org.geotoolkit.jdbc.fid.PrimaryKey;
import org.geotoolkit.jdbc.fid.AutoGeneratedPrimaryKeyColumn;
import org.geotoolkit.jdbc.fid.NullPrimaryKey;
import org.geotoolkit.jdbc.fid.NonIncrementingPrimaryKeyColumn;
import org.geotoolkit.jdbc.fid.SequencedPrimaryKeyColumn;

import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.feature.type.AttributeDescriptor;
import org.opengis.feature.type.AttributeType;
import org.opengis.feature.type.ComplexType;
import org.opengis.feature.type.FeatureType;
import org.opengis.feature.type.FeatureTypeFactory;
import org.opengis.feature.type.Name;
import org.opengis.feature.type.PropertyDescriptor;
import org.opengis.feature.type.PropertyType;
import org.opengis.referencing.crs.CoordinateReferenceSystem;

import static org.geotoolkit.jdbc.reverse.MetaDataConstants.*;
import static org.geotoolkit.jdbc.AbstractJDBCDataStore.*;

/**
 * Represent the structure of the database. The work done here is similar to
 * reverse engineering.
 *
 * @author Johann Sorel (Geomatys)
 */
public final class DataBaseModel {

    /**
     * Custom factory where types can be modified after they are created.
     */
    private static final FeatureTypeFactory FTF = new ModifiableFeatureTypeFactory();
    /**
     * Dummy type which will be replaced dynamically in the reverse engineering process.
     */
    private static final ComplexType FLAG_TYPE = FTF.createComplexType(
            new DefaultName("flag"), Collections.EMPTY_LIST, false, false, Collections.EMPTY_LIST, null, null);

    private Map<String,SchemaMetaModel> schemas = null;

    private final DefaultJDBCDataStore store;
    private final Map<Name,PrimaryKey> primaryKeys = new HashMap<Name, PrimaryKey>();
    private final Map<Name,FeatureType> names = new HashMap<Name, FeatureType>();
    private Set<Name> nameCache = null;

    public DataBaseModel(final DefaultJDBCDataStore store){
        this.store = store;
    }

    /**
     * Clear the model cache. A new database analyze will be made the next time
     * it is needed.
     */
    public void clearCache(){
        primaryKeys.clear();
        names.clear();
        nameCache = null;
        schemas = null;
    }

    public PrimaryKey getPrimaryKey(final Name featureTypeName) throws DataStoreException{
        if(nameCache == null){
            visitTables();
        }
        return primaryKeys.get(featureTypeName);
    }

    public synchronized Set<Name> getNames() throws DataStoreException {
        Set<Name> ref = nameCache;
        if(ref == null){
            visitTables();
            ref = Collections.unmodifiableSet(new HashSet<Name>(names.keySet()));
            nameCache = ref;
        }
        return ref;
    }

    public FeatureType getFeatureType(final Name typeName) throws DataStoreException {
        return names.get(typeName);
    }

    /**
     * Explore all tables and views then recreate a complex feature model from
     * relations.
     */
    private void analyze() throws DataStoreException{
        clearCache();
        schemas = new HashMap<String, SchemaMetaModel>();

        final String baseSchemaName = store.getDatabaseSchema();

        Connection cx = null;
        ResultSet schemaSet = null;
        try {
            cx = store.createConnection();

            final DatabaseMetaData metadata = cx.getMetaData();
            schemaSet = metadata.getSchemas();
            while (schemaSet.next()) {
                final String SchemaName = schemaSet.getString(Schema.TABLE_SCHEM);
                final SchemaMetaModel schema = analyzeSchema(SchemaName);
                schemas.put(schema.name, schema);
            }

        } catch (SQLException e) {
            throw new DataStoreException("Error occurred analyzing database model.", e);
        } finally {
            store.closeSafe(schemaSet);
            store.closeSafe(cx);
        }

        reverseSimpleFeatureTypes();
        reverseComplexFeatureTypes();
    }

    private SchemaMetaModel analyzeSchema(final String schemaName) throws DataStoreException{

        final SchemaMetaModel schema = new SchemaMetaModel(schemaName);

        Connection cx = null;
        ResultSet tableSet = null;
        try {
            cx = store.createConnection();

            final DatabaseMetaData metadata = cx.getMetaData();
            tableSet = metadata.getTables(null, schemaName, "%",
                    new String[]{Table.VALUE_TYPE_TABLE, Table.VALUE_TYPE_VIEW});

            while (tableSet.next()) {
                final TableMetaModel table = analyzeTable(tableSet);
                schema.tables.put(table.name, table);
            }

        } catch (SQLException e) {
            throw new DataStoreException("Error occurred analyzing database model.", e);
        } finally {
            store.closeSafe(tableSet);
            store.closeSafe(cx);
        }

        return schema;
    }

    private TableMetaModel analyzeTable(final ResultSet tableSet) throws DataStoreException, SQLException{
        final SQLDialect dialect = store.getDialect();
        final FeatureTypeBuilder ftb = new FeatureTypeBuilder(FTF);

        final String schemaName = tableSet.getString(Table.TABLE_SCHEM);
        final String tableName = tableSet.getString(Table.TABLE_NAME);

        final TableMetaModel table = new TableMetaModel(tableName);
        
        Connection cx = null;
        ResultSet result = null;
        try {
            cx = store.createConnection();
            final DatabaseMetaData metadata = cx.getMetaData();

            //explore all columns ----------------------------------------------
            result = metadata.getColumns(null, schemaName, tableName, "%");
            while (result.next()) {
                final PropertyDescriptor desc = analyzeColumn(result);
                ftb.add(analyzeColumn(result));
            }
            store.closeSafe(result);

            //find primary key -------------------------------------------------
            final List<PrimaryKeyColumn> cols = new ArrayList();
            result = metadata.getPrimaryKeys(null, schemaName, tableName);
            while (result.next()) {
                final String columnName = result.getString(Column.COLUMN_NAME);

                //look up the type ( should only be one row )
                final ResultSet columns = metadata.getColumns(null, schemaName, tableName, columnName);
                columns.next();

                final int binding = columns.getInt(Column.DATA_TYPE);
                Class columnType = dialect.getMapping(binding);

                if (columnType == null) {
                    store.getLogger().log(Level.WARNING, "No class for sql type {0}", binding);
                    columnType = Object.class;
                }

                //determine which type of primary key we have
                PrimaryKeyColumn col = null;

                //1. Auto Incrementing?
                final String str = columns.getString(Column.IS_AUTOINCREMENT);
                if(Column.VALUE_YES.equalsIgnoreCase(str)){
                    col = new AutoGeneratedPrimaryKeyColumn(columnName, columnType);
                }

                //2. Has a sequence?
                if (col == null) {
                    final String sequenceName = dialect.getSequenceForColumn(
                            schemaName, tableName, columnName, cx);
                    if (sequenceName != null) {
                        col = new SequencedPrimaryKeyColumn(columnName, columnType, sequenceName);
                    }
                }

                if (col == null) {
                    col = new NonIncrementingPrimaryKeyColumn(columnName, columnType);
                }

                cols.add(col);
            }

            if (cols.isEmpty()) {
                store.getLogger().log(Level.INFO, "No primary key found for {0}.", tableName);
                table.key = new NullPrimaryKey(tableName);
            } else {
                table.key = new PrimaryKey(tableName, cols);
            }
            store.closeSafe(result);

            //find imported keys -----------------------------------------------
            result = metadata.getImportedKeys(null, schemaName, tableName);
            while (result.next()) {
                final String localColumn = result.getString(ImportedKey.FKCOLUMN_NAME);
                final String refSchemaName = result.getString(ImportedKey.PKTABLE_SCHEM);
                final String refTableName = result.getString(ImportedKey.PKTABLE_NAME);
                final String refColumnName = result.getString(ImportedKey.PKCOLUMN_NAME);
                table.importedKeys.add(new RelationMetaModel(localColumn,
                        refSchemaName, refTableName, refColumnName, true));
            }
            store.closeSafe(result);

            //find exported keys -----------------------------------------------
            result = metadata.getExportedKeys(null, schemaName, tableName);
            while (result.next()) {
                final String localColumn = result.getString(ExportedKey.PKCOLUMN_NAME);
                final String refSchemaName = result.getString(ExportedKey.FKTABLE_SCHEM);
                final String refTableName = result.getString(ExportedKey.FKTABLE_NAME);
                final String refColumnName = result.getString(ExportedKey.FKCOLUMN_NAME);
                table.exportedKeys.add(new RelationMetaModel(localColumn,
                        refSchemaName, refTableName, refColumnName, false));
            }
            store.closeSafe(result);

        } catch (SQLException e) {
            throw new DataStoreException("Error occurred analyzing table : " + tableName, e);
        } finally {
            store.closeSafe(result);
            store.closeSafe(cx);
        }

        ftb.setName(tableName);
        table.baseType = ftb.buildType();
        return table;
    }

    private AttributeDescriptor analyzeColumn(final ResultSet columnSet) throws SQLException, DataStoreException{
        final SQLDialect dialect = store.getDialect();
        final AttributeDescriptorBuilder adb = new AttributeDescriptorBuilder(FTF);
        final AttributeTypeBuilder atb = new AttributeTypeBuilder(FTF);

        final String columnName     = columnSet.getString(Column.COLUMN_NAME);
        final int columnDataType    = columnSet.getInt(Column.DATA_TYPE);
        final String columnTypeName = columnSet.getString(Column.TYPE_NAME);
        final String columnNullable = columnSet.getString(Column.IS_NULLABLE);


        Connection cx = null;
        Class binding;
        try {
            cx = store.createConnection();
            binding = dialect.getMapping(columnSet, cx);

        } catch (SQLException e) {
            throw new DataStoreException("Error occurred analyzing column : " + columnName, e);
        } finally {
            store.closeSafe(cx);
        }


        if (binding == null) {
            //determine from type mappings
            binding = dialect.getMapping(columnDataType);
        }
        if (binding == null) {
            //determine from type name mappings
            binding = dialect.getMapping(columnTypeName);
        }
        if (binding == null) {
            //if still not found, resort to Object
            store.getLogger().log(Level.WARNING, "Could not find mapping for:{0}", columnName);
            binding = Object.class;
        }

        //table values are always min 1, max 1
        adb.setMinOccurs(1);
        adb.setMaxOccurs(1);

        //nullability
        if (Column.VALUE_NO.equalsIgnoreCase(columnNullable)) {
            adb.setNillable(false);
        }else{
            adb.setNillable(true);
        }

        atb.setName(columnName);
        atb.setBinding(binding);

        adb.setName(columnName);
        adb.setType(atb.buildType());
        adb.findBestDefaultValue();
        return adb.buildDescriptor();
    }

    /**
     * Rebuild simple feature types for each table.
     */
    private void reverseSimpleFeatureTypes(){
        final SQLDialect dialect = store.getDialect();

        final FeatureTypeBuilder ftb = new FeatureTypeBuilder(FTF);
        final AttributeDescriptorBuilder adb = new AttributeDescriptorBuilder(FTF);
        final AttributeTypeBuilder atb = new AttributeTypeBuilder(FTF);

        for(final SchemaMetaModel schema : schemas.values()){
            for(final TableMetaModel table : schema.tables.values()){
                final String tableName = table.name;

                //add flag for primary key fields-------------------------------
                final PrimaryKey pk = table.key;
                for(PrimaryKeyColumn column : pk.getColumns()){
                    final String attName = column.getName();
                    final PropertyDescriptor base = table.baseType.getDescriptor(attName);
                    base.getUserData().put(HintsPending.PROPERTY_IS_IDENTIFIER, Boolean.TRUE);
                }


                //fill the namespace--------------------------------------------
                ftb.reset();
                ftb.copy(table.baseType);
                final String namespace = store.getNamespaceURI();
                ftb.setName(namespace, ftb.getName().getLocalPart());


                final List<PropertyDescriptor> descs = ftb.getProperties();

                for(int i=0,n=descs.size(); i<n; i++){
                    final PropertyDescriptor desc = descs.get(i);
                    final PropertyType type = desc.getType();
                    final String name = desc.getName().getLocalPart();

                    adb.reset();
                    adb.copy((AttributeDescriptor) desc);
                    adb.setName(ensureGMLNS(namespace,name));
                    atb.reset();
                    atb.copy((AttributeType) type);
                    atb.setName(ensureGMLNS(namespace,name));
                    adb.setType(atb.buildType());

                    //Set the CRS if it's a geometry
                    if (Geometry.class.isAssignableFrom(type.getBinding())) {
                        //add the attribute as a geometry, try to figure out
                        // its srid first
                        Integer srid = null;
                        CoordinateReferenceSystem crs = null;
                        Connection cx = null;
                        try {
                            cx = store.createConnection();
                            srid = dialect.getGeometrySRID(store.getDatabaseSchema(), tableName, name, cx);
                            if(srid != null)
                                crs = dialect.createCRS(srid, cx);
                        } catch (SQLException e) {
                            String msg = "Error occured determing srid for " + tableName + "."+ name;
                            store.getLogger().log(Level.WARNING, msg, e);
                        } finally{
                            store.closeSafe(cx);
                        }

                        atb.setCRS(crs);
                        if(srid != null){
                            adb.addUserData(JDBCDataStore.JDBC_NATIVE_SRID, srid);
                        }
                        adb.setType(atb.buildGeometryType());
                        adb.findBestDefaultValue();
                    }

                    descs.set(i, adb.buildDescriptor());
                }

                table.simpleType = ftb.buildSimpleFeatureType();
            }
        }
    }

    /**
     * Rebuild complex feature types using foreign key relations.
     */
    private void reverseComplexFeatureTypes(){
        final FeatureTypeBuilder ftb = new FeatureTypeBuilder(FTF);
        final AttributeDescriptorBuilder adb = new AttributeDescriptorBuilder(FTF);
        
        //result map
        final Map<String,ModifiableType> builded = new HashMap<String, ModifiableType>();

        //first pass to create the real types but without relations types-------
        //since we must have all of them before creating relations
        for(final SchemaMetaModel schema : schemas.values()){
            for(final TableMetaModel table : schema.tables.values()){
                final String code = schema.name +"."+table.name;

                //create the complex model by replacing descriptors
                final ComplexType baseType = table.simpleType;
                ftb.reset();
                ftb.copy(baseType);

                // replace 0:1 relations
                for(final RelationMetaModel relation : table.importedKeys){

                    //find the descriptor to replace
                    final List<PropertyDescriptor> descs = ftb.getProperties();
                    int index = -1;
                    for(int i=0,n=descs.size();i<n;i++){
                        final PropertyDescriptor pd = descs.get(i);
                        if(pd.getName().getLocalPart().equals(relation.currentColumn)){
                            index = i;
                        }
                    }

                    //create the new descriptor derivated
                    final PropertyDescriptor baseDescriptor = descs.get(index);
                    adb.reset();
                    adb.copy((AttributeDescriptor) baseDescriptor);
                    adb.setType(FLAG_TYPE);
                    adb.setDefaultValue(null);
                    final PropertyDescriptor newDescriptor = adb.buildDescriptor();
                    descs.set(index, newDescriptor);
                }

                // create N:1 relations
                for(final RelationMetaModel relation : table.exportedKeys){

                    adb.reset();
                    adb.setName(relation.foreignTable);
                    adb.setType(FLAG_TYPE);
                    adb.setMinOccurs(0);
                    adb.setMaxOccurs(Integer.MAX_VALUE);
                    adb.setNillable(false);
                    adb.setDefaultValue(null);
                    ftb.add(adb.buildDescriptor());
                }

                final FeatureType ft = ftb.buildFeatureType();
                builded.put(code, (ModifiableType) ft);

                table.complexType = ft;
            }
        }

        //second pass to fill relations-----------------------------------------
        for(final SchemaMetaModel schema : schemas.values()){
            for(final TableMetaModel table : schema.tables.values()){
                final String code = schema.name +"."+table.name;

                //modify the properties which are relations
                final ModifiableType candidate = builded.get(code);

                //replace 0:1 relations types
                for(final RelationMetaModel relation : table.importedKeys){
                    final String relCode = relation.foreignSchema +"."+relation.foreignTable;
                    final ComplexType relType = builded.get(relCode);
                    
                    //find the descriptor to replace
                    final List<PropertyDescriptor> descs = candidate.getDescriptors();
                    int index = -1;
                    for(int i=0,n=descs.size();i<n;i++){
                        final PropertyDescriptor pd = descs.get(i);
                        if(pd.getName().getLocalPart().equals(relation.currentColumn)){
                            index = i;
                        }
                    }

                    //create the new descriptor derivated
                    final PropertyDescriptor baseDescriptor = descs.get(index);
                    adb.reset();
                    adb.copy((AttributeDescriptor) baseDescriptor);
                    adb.setType(relType);
                    final PropertyDescriptor newDescriptor = adb.buildDescriptor();
                    candidate.changeProperty(index, newDescriptor);
                }

                //replace N:1 relations types
                for(final RelationMetaModel relation : table.exportedKeys){
                    final String relCode = relation.foreignSchema +"."+relation.foreignTable;
                    final ComplexType relType = builded.get(relCode);

                    //find the descriptor to replace
                    final List<PropertyDescriptor> descs = candidate.getDescriptors();
                    int index = -1;
                    for(int i=0,n=descs.size();i<n;i++){
                        final PropertyDescriptor pd = descs.get(i);
                        if(pd.getName().getLocalPart().equals(relation.foreignTable)){
                            index = i;
                        }
                    }

                    //create the new descriptor derivated
                    final PropertyDescriptor baseDescriptor = descs.get(index);
                    adb.reset();
                    adb.copy((AttributeDescriptor) baseDescriptor);
                    adb.setType(relType);
                    final PropertyDescriptor newDescriptor = adb.buildDescriptor();
                    candidate.changeProperty(index, newDescriptor);
                }
            }
        }

    }

    /**
     * Explore the available tables and generate schemas and primary keys.
     * @throws DataStoreException
     */
    private synchronized void visitTables() throws DataStoreException{
        //analyze();
        final SQLDialect dialect = store.getDialect();

        //clear previous schemas, this might be called after an update schema
        nameCache = null;
        names.clear();
        primaryKeys.clear();
        Connection cx = null;
        try {
            cx = store.createConnection();
            final DatabaseMetaData metaData = cx.getMetaData();
            final ResultSet tables = metaData.getTables(null, store.getDatabaseSchema(), "%", new String[]{Table.VALUE_TYPE_TABLE, Table.VALUE_TYPE_VIEW});

            try {
                while (tables.next()) {

                    final String schemaName = tables.getString(Table.TABLE_SCHEM);
                    final String tableName = tables.getString(Table.TABLE_NAME);

                    //use the dialect to filter
                    if (!dialect.includeTable(schemaName, tableName, cx)) {
                        continue;
                    }

                    final Name name = new DefaultName(store.getNamespaceURI(), tableName);
                    final SimpleFeatureType sft = createFeatureType(name);
                    final PrimaryKey pkey = createPrimaryKey(name);
                    names.put(name, sft);
                    primaryKeys.put(name, pkey);
                }
            } finally {
                store.closeSafe(tables);
            }
        } catch (SQLException e) {
            throw new DataStoreException("Error occurred getting table name list.", e);
        } finally {
            store.closeSafe(cx);
        }

    }

    /**
     * Builds the feature type from database metadata.
     */
    private SimpleFeatureType createFeatureType(final Name typeName) throws DataStoreException {
        final SQLDialect dialect = store.getDialect();
        final FeatureTypeBuilder tb = new FeatureTypeBuilder();
        final AttributeDescriptorBuilder adb = new AttributeDescriptorBuilder();
        final AttributeTypeBuilder atb = new AttributeTypeBuilder();

        //set up the name
        final String tableName = typeName.getLocalPart();
        final String namespace = typeName.getNamespaceURI();
        tb.setName(typeName);

        //ensure we have a connection
        Connection cx = null;
        ResultSet columns = null;
        try {
            cx = store.createConnection();
            final DatabaseMetaData metaData = cx.getMetaData();
            columns = metaData.getColumns(null, store.getDatabaseSchema(), tableName, "%");

            columnIte :
            while (columns.next()) {
                adb.reset();
                atb.reset();

                final String name = columns.getString(Column.COLUMN_NAME);

                //figure out the type mapping

                //first ask the dialect
                Class binding = dialect.getMapping(columns, cx);

                if (binding == null) {
                    //determine from type mappings
                    final int dataType = columns.getInt(Column.DATA_TYPE);
                    binding = dialect.getMapping(dataType);
                }

                if (binding == null) {
                    //determine from type name mappings
                    final String tn = columns.getString(Column.TYPE_NAME);
                    binding = dialect.getMapping(tn);
                }

                //if still not found, resort to Object
                if (binding == null) {
                    store.getLogger().log(Level.WARNING, "Could not find mapping for:{0}", name);
                    binding = Object.class;
                }

                adb.setMinOccurs(1);
                //nullability
                if ( Column.VALUE_NO.equalsIgnoreCase( columns.getString(Column.IS_NULLABLE) ) ) {
                    adb.setNillable(false);
                }else{
                    adb.setNillable(true);
                }

                //primary key never null, min one
                final ResultSet primaryKeys = metaData.getPrimaryKeys(null, store.getDatabaseSchema(), tableName);
                try {
                    while (primaryKeys.next()) {
                        if (name.equals(primaryKeys.getString(Column.COLUMN_NAME))) {
                            adb.setNillable(false);
                            adb.setMinOccurs(1);
                            adb.addUserData(HintsPending.PROPERTY_IS_IDENTIFIER, Boolean.TRUE);
                            break;
                        }
                    }
                } finally {
                    store.closeSafe(primaryKeys);
                }


                //determine if this attribute is a geometry or not
                if (Geometry.class.isAssignableFrom(binding)) {
                    //add the attribute as a geometry, try to figure out
                    // its srid first
                    Integer srid = null;
                    CoordinateReferenceSystem crs = null;
                    try {
                        srid = dialect.getGeometrySRID(store.getDatabaseSchema(), tableName, name, cx);
                        if(srid != null)
                            crs = dialect.createCRS(srid, cx);
                    } catch (SQLException e) {
                        String msg = "Error occured determing srid for " + tableName + "."+ name;
                        store.getLogger().log(Level.WARNING, msg, e);
                    }

                    atb.setBinding(binding);
                    atb.setName(ensureGMLNS(namespace,name));
                    atb.setCRS(crs);
                    if(srid != null) adb.addUserData(JDBCDataStore.JDBC_NATIVE_SRID, srid);
                    adb.setName(ensureGMLNS(namespace,name));
                    adb.setType(atb.buildGeometryType());
                    adb.findBestDefaultValue();
                    tb.add(adb.buildDescriptor());
                } else {
                    //add the attribute
                    final Name attName = ensureGMLNS(namespace, name);
                    atb.setName(attName);
                    atb.setBinding(binding);
                    adb.setName(attName);
                    adb.setType(atb.buildType());
                    adb.findBestDefaultValue();
                    tb.add(adb.buildDescriptor());
                }
            }

            return tb.buildSimpleFeatureType();

        } catch (SQLException e) {
            throw new DataStoreException("Error occurred building feature type", e);
        }finally {
            store.closeSafe(columns);
            store.closeSafe(cx);
        }
    }

    /**
     * Returns the primary key object for a particular entry, deriving it from
     * the underlying database metadata.
     */
    private PrimaryKey createPrimaryKey(final Name entry) throws DataStoreException {
        final SQLDialect dialect = store.getDialect();

        PrimaryKey pkey;

        Connection cx = null;
        try {
            //get metadata from database
            cx = store.createConnection();
            final String tableName = entry.getLocalPart();
            final DatabaseMetaData metaData = cx.getMetaData();
            final ResultSet primaryKey = metaData.getPrimaryKeys(null, store.getDatabaseSchema(), tableName);

            try {
                final ArrayList<PrimaryKeyColumn> cols = new ArrayList();

                while (primaryKey.next()) {
                    final String columnName = primaryKey.getString(Column.COLUMN_NAME);

                    //look up the type ( should only be one row )
                    final ResultSet columns = metaData.getColumns(null, store.getDatabaseSchema(), tableName, columnName);
                    columns.next();

                    final int binding = columns.getInt(Column.DATA_TYPE);
                    Class columnType = dialect.getMapping(binding);

                    if (columnType == null) {
                        store.getLogger().log(Level.WARNING, "No class for sql type {0}", binding);
                        columnType = Object.class;
                    }

                    //determine which type of primary key we have
                    PrimaryKeyColumn col = null;

                    //1. Auto Incrementing?
                    final String str = columns.getString(Column.IS_AUTOINCREMENT);
                    if(Column.VALUE_YES.equalsIgnoreCase(str)){
                        col = new AutoGeneratedPrimaryKeyColumn(columnName, columnType);
                    }
                    
                    //2. Has a sequence?
                    if (col == null) {
                        //TODO: look for a sequence
                        final String sequenceName = dialect.getSequenceForColumn(store.getDatabaseSchema(),
                                tableName, columnName, cx);
                        if (sequenceName != null) {
                            col = new SequencedPrimaryKeyColumn(columnName, columnType, sequenceName);
                        }
                    }

                    if (col == null) {
                        col = new NonIncrementingPrimaryKeyColumn(columnName, columnType);
                    }

                    cols.add(col);
                }

                if (cols.isEmpty()) {
                    store.getLogger().log(Level.INFO, "No primary key found for {0}.", tableName);
                    pkey = new NullPrimaryKey(tableName);
                } else {
                    pkey = new PrimaryKey(tableName, cols);
                }

            } finally {
                store.closeSafe(primaryKey);
            }
        } catch (SQLException e) {
            throw new DataStoreException("Error looking up primary key", e);
        } finally {
            store.closeSafe(cx);
        }

        return pkey;
    }

}
